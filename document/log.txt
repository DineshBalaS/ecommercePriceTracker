# E-commerce Price Tracker Project Log

## Objective

Develop a full-stack web application that monitors prices of products across various e-commerce websites and notifies users when prices drop below a certain threshold.

## Tech Stack

* **Backend**: FastAPI
* **Frontend**: React + Tailwind CSS
* **Scraping**: BeautifulSoup / Playwright / Selenium
* **Database**: MongoDB or PostgreSQL (TBD)
* **DevOps**: Docker, CI/CD, optional Kubernetes deployment
* **Notifications**: Email via SMTP / Push (TBD)

---

## Phase 1: Planning

**Start Date:** 2025-05-30

### Key Features

1. User Registration & Login
2. Product Tracker (Add product URLs, set desired price)
3. Scheduled Scraping (Monitor product prices regularly)
4. Price Drop Alerts (via email/notifications)
5. Dashboard to view tracked products and current prices
6. Graphs for price history trends (per product)

### Target Sites for Scraping (tentative)

* Amazon (caution: bot protection)
* Flipkart
* Croma
* Reliance Digital
* Public APIs (if any)

---

## Phase 2: Setup

**Status:** Done ✅

### Tasks

* [x] Set up project repo & file structure
* [x] Initialize FastAPI backend with basic routes
* [x] Set up React frontend with Tailwind CSS
* [x] Containerize backend and frontend with Docker
* [x] Configure MongoDB/PostgreSQL connection

---

## Phase 3: Core Backend Logic

**Status:** ongoing

### Tasks

* [x] Build user model and auth system
* [x] Implement product tracking model
* [x] Develop scraping module for target websites
* [x] Schedule scraping jobs using Celery/APScheduler (TBF)
* [ ] Integrate email/notification system (TBF)

---

## Phase 4: Frontend Development

**Status:** Pending

### Tasks

* [ ] Auth UI (login/signup) (yet to link them together)
* [ ] Dashboard to view tracked products
* [ ] Forms for adding/editing tracked products

---

## Phase 5: Deployment

**Status:** Pending

### Tasks

* [ ] CI/CD Pipeline (GitHub Actions)
* [ ] Docker Compose for local dev
* [ ] Production deployment (Render/AWS/DigitalOcean)

---

## Notes

* Explore usage of rotating user agents/proxies if bot detection becomes a problem
* Document all endpoints and create OpenAPI docs via FastAPI
* Include retry/failure handling in scraping logic
* Ensure legal/ethical scraping by reviewing site ToS

planned Project folder structure :- 
ecommerce-price-tracker/
├── backend/
│   ├── app/
│   │   ├── main.py
│   │   ├── models/
│   │   │   └── user.py, product.py
│   │   ├── routes/
│   │   │   └── auth.py, product.py
│   │   ├── services/
│   │   │   └── scraper.py, notification.py
│   │   └── config.py
│   ├── requirements.txt
│   └── Dockerfile
├── frontend/
│   ├── public/
│   ├── src/
│   │   ├── components/
│   │   ├── pages/
│   │   └── App.jsx
│   ├── tailwind.config.js
│   ├── package.json
│   └── Dockerfile
├── docker-compose.yml
├── .env (for secrets)
└── README.md

current backend folder - > 

C:\USERS\DINESH\DOCUMENTS\MP\PRICETRACKERAPP\BACKEND
│   .env
│   requirements.txt
│   
└───app
    │   config.py
    │   Dockerfile
    │   main.py
    │   __init__.py
    │
    ├───models
    │   │   product.py
    │   │   user.py
    │   │
    │   └───__pycache__
    │           product.cpython-311.pyc
    │           user.cpython-311.pyc
    │
    ├───routes
    │   │   auth.py
    │   │   product.py
    │   │
    │   └───__pycache__
    │           auth.cpython-311.pyc
    │           product.cpython-311.pyc
    │
    ├───services
    │   │   auth_utils.py
    │   │   flipkart_scraper.py
    │   │   scraper.py
    │   │   scraper_dispatcher.py
    │   │   tracker.py
    │   │
    │   └───__pycache__
    │           auth_utils.cpython-311.pyc
    │           flipkart_scraper.cpython-311.pyc
    │           scraper.cpython-311.pyc
    │           scraper_dispatcher.cpython-311.pyc
    │           tracker.cpython-311.pyc
    │
    ├───utils
    │   │   mongo.py
    │   │   objectid.py
    │   │
    │   └───__pycache__
    │           mongo.cpython-311.pyc
    │           objectid.cpython-311.pyc
    │
    └───__pycache__
            config.cpython-311.pyc
            main.cpython-311.pyc
            __init__.cpython-311.pyc

this is my current frontend structure - > frontend has three main folders - > node modules, sources and public here is public

```tree /f C:\Users\Dinesh\Documents\mp\priceTrackerApp\frontend\public
Folder PATH listing for volume OS
Volume serial number is 262A-D645
C:\USERS\DINESH\DOCUMENTS\MP\PRICETRACKERAPP\FRONTEND\PUBLIC
    favicon.ico
    index.html
    logo192.png
    logo512.png
    manifest.json
    robots.txt

No subfolders exist

(venv) PS C:\Users\Dinesh\Documents\mp\priceTrackerApp>```

and here is src - >

``` tree /f C:\Users\Dinesh\Documents\mp\priceTrackerApp\frontend\src   
Folder PATH listing for volume OS
Volume serial number is 262A-D645
C:\USERS\DINESH\DOCUMENTS\MP\PRICETRACKERAPP\FRONTEND\SRC
    App.css
    App.js
    App.test.js
    index.css
    index.js
    logo.svg
    reportWebVitals.js
    setupTests.js

No subfolders exist

(venv) PS C:\Users\Dinesh\Documents\mp\priceTrackerApp>```


next plan for product page - > 

Implementation Plan for Product Detail Page - Backend (Phase 1)
Last Updated: 2025-08-05

==================================================
AC-1: [DB Schema] Update Product Model
==================================================
File: app/models/product.py
Status: Done

[x] 1.1: Create `PriceHistoryItem` Model
    - Define a new `BaseModel` called `PriceHistoryItem`.
    - It will contain `price: Optional[float]` (to handle failed scrapes) and `timestamp: datetime`.

[x] 1.2: Update `ProductInDB` Model
    - Add the new fields to the `ProductInDB` class:
        - `price_history: List[PriceHistoryItem] = []`
        - `historical_low_price: Optional[float] = None`
        - `historical_high_price: Optional[float] = None`

[x] 1.3: Update `ProductOut` Model
    - Mirror the changes from `ProductInDB` in the `ProductOut` class so the new data is sent to the frontend.

==================================================
AC-2: [Tracker Logic] Modify Tracker Script
==================================================
File: app/services/tracker.py (function: update_price_for_product)
Status: Pending

[x] 2.1: Adjust Price Parsing
    - Modify logic to set `price_num` to `None` if scraping fails or returns no price, instead of the current `0.0`.

[x] 2.2: Build Dynamic Update Payload
    - Construct a complex payload that ALWAYS uses `$push` to add a new `PriceHistoryItem` to the `price_history` array (with either the scraped price or `None`).

[x] 2.3: Implement Conditional `$set`
    - Add logic to build the `$set` object ONLY if `price_num` is not `None`:
      a) Set the `current_price`.
      b) Compare `price_num` with `product.get("historical_low_price")`. If it's a new low (or the first price), add `historical_low_price` to the `$set` object.
      c) Do the same for `historical_high_price`.

[x] 2.4: Execute Combined Update
    - Use the new payload in the `product_collection.update_one()` call, combining `$push` and `$set` operations into a single database write.

==================================================
AC-3: [New API Endpoint] Create GET /api/products/{id}
==================================================
File: app/routes/product.py
Status: Done

[x] 3.1: Define New Route
    - Create a new endpoint: `@product_router.get("/{id}", response_model=ProductOut)`.

[x] 3.2: Add Authorization
    - Ensure the route uses the `current_user: UserInDB = Depends(get_current_user)` dependency.

[x] 3.3: Fetch Product with Ownership Check
    - Find the product where `_id` matches the path `id` AND `owner_id` matches `current_user.id`.

[x] 3.4: Handle Not Found
    - If no product is found, raise a `404 Not Found` HTTPException.

[x] 3.5: Return Product
    - If found, use the existing `format_product()` helper function to prepare and return the data.

==================================================
AC-4: [API Enhancement] Enhance PATCH /api/products/{id}
==================================================
File: app/routes/product.py and app/models/product.py
Status: Pending

[x] 4.1: Create `ProductUpdate` Model
    - In `app/models/product.py`, create a new model: `class ProductUpdate(BaseModel): desired_price: Optional[float] = None; notes: Optional[str] = None`.

[x] 4.2: Update Endpoint Signature
    - In `app/routes/product.py`, change the signature of the `update_product` function from `update_data: dict` to `update_data: ProductUpdate`.

[x] 4.3: Refine Update Logic
    - Replace the generic `update_data` dictionary with `update_data.model_dump(exclude_unset=True)` to build the `$set` payload cleanly and safely.


==================================================
Frontend Plan: Product Detail Page (Phase 2)
==================================================

This plan outlines the steps to create the new Product Detail page, leveraging the existing architecture and patterns.

--------------------------------------------------
Part 1: API and Routing Setup (AC-5)
--------------------------------------------------
Objective: Prepare the API layer for new requests and set up the new page route.

[X] 1.1: Enhance API Layer
    - File: src/api/api.js
    - Action: Add two new exported functions:
        - `getProductById(productId)`: Performs a GET request to `/api/products/${productId}`.
        - `updateProductDetails(productId, data)`: Performs a PATCH request to `/api/products/${productId}` with the provided data payload.

[x] 1.2: Add New Page Route
    - File: src/App.js
    - Action:
        - Import the new `ProductDetailPage` component (which we will create).
        - Add a new `<Route>` inside `<Routes>`:
          <Route path="/product/:id" element={<ProtectedRoute><ProductDetailPage /></ProtectedRoute>} />

[x] 1.3: Make Dashboard Products Clickable
    - File: src/pages/Dashboard.jsx
    - Action:
        - Import { Link } from "react-router-dom".
        - In the `.map()` function that renders product cards, wrap the main `div` of the card with a `<Link>` component.
        - The link's destination should be `to={'/product/${product.id}'}`.

--------------------------------------------------
Part 2: Build ProductDetailPage Component (AC-6, AC-10)
--------------------------------------------------
Objective: Create the main page component, fetch data, and handle loading/error states.

[x] 2.1: Create New Component File
    - New File: src/pages/ProductDetailPage.jsx

[x] 2.2: Set Up Component State
    - Action: Inside the `ProductDetailPage` component:
        - Get the product ID from the URL using the `useParams` hook.
        - Initialize state variables using `useState`:
            - `product` (default: null)
            - `isLoading` (default: true)
            - `error` (default: null)

[x] 2.3: Fetch Product Data
    - Action: Use a `useEffect` hook to fetch data when the component loads.
        - Call the `getProductById(id)` function from `api.js`.
        - On success, update the `product` state.
        - On failure, update the `error` state.
        - Use a `finally` block to set `isLoading` to `false`.

[x] 2.4: Implement Conditional Rendering
    - Action: In the JSX, render content based on the state:
        - If `isLoading`, show a loading message/spinner.
        - If `error`, show an error message.
        - If `product` is loaded, render the page content.

--------------------------------------------------
Part 3: Implement UI Panels (AC-7, AC-8, AC-9)
--------------------------------------------------
Objective: Build the three main UI sections of the page within ProductDetailPage.jsx.

[x] 3.1: Build Vitals Panel (AC-7)
    - Action: Create a section to display the key price points.
        - Render `product.current_price`, `product.desired_price`, `product.historical_low_price`, and `product.historical_high_price`.
        - Add a small up/down arrow icon next to the current price by comparing the last two entries in `product.price_history`.

[x] 3.2: Build Price History Chart (AC-8)
    - Action:
        - Install a charting library: `npm install recharts`.
        - Create state for the active time range filter: `const [timeRange, setTimeRange] = useState('All');`
        - Create buttons (1W, 1M, 6M, All) that update this `timeRange` state.
        - Write a helper function to filter `product.price_history` based on the selected `timeRange`.
        - Render the Recharts `<LineChart>` component with the filtered data.
        - Configure the `<Tooltip>` to show price and formatted date on hover. (Recommended: `npm install date-fns`).

[x] 3.3: Build User Settings Panel (AC-9)
    - Action:
        - Create a `<form>` element for user settings.
        - Use controlled components for the `desired_price` input and `notes` textarea. This will require new state variables.
        - Use a `useEffect` to populate these form fields with `product.desired_price` and `product.notes` once the product data is loaded.
        - The "Save" button's `onClick` handler will call the `updateProductDetails()` API function with the new form values.
        - Add state to handle the saving process (e.g., a "Saving..." message on the button).

Cron job Feature - > 

### Implementation Plan: Automated, Robust Scheduling for Price Tracker

**Story:** `As a developer, I want to automate the price tracking script to run periodically without manual intervention, so that product prices are updated reliably and consistently for all users.`
**Status:** `PLANNING_COMPLETE`
**Assignee:** `Gemini`

---

#### Phase 1: Code Refactoring & Hardening (AC-1, AC-3)

*This phase focuses on making the script robust, maintainable, and ready for an unattended environment.*

* **Task 1.1: Centralize Configuration**
    * `[x]` **Status: DONE**
    * **Action:** Modify `backend/app/services/tracker.py` to remove the hardcoded `MONGO_URI` and `DB_NAME`.
    * **Action:** Import and use the existing `db` instance from `backend/app/config.py`.
    * **Reasoning:** Eliminates duplicate configuration and makes the script respect the `.env` file, which is crucial for different environments (dev/prod).

* **Task 1.2: Implement Centralized Logging**
    * `[x]` **Status: DONE**
    * **Action:** Create a new file `backend/app/utils/logger.py` to configure a shared logger instance.
        * The logger will have a `StreamHandler` to print to the console (for manual runs).
        * The logger will have a `FileHandler` to write to `backend/tracker.log`.
        * The log format will be: `%(asctime)s - %(levelname)s - %(message)s`.
    * **Action:** In `backend/app/config.py`, add a new variable `LOG_FILE = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'tracker.log')`.
    * **Action:** Replace all `print()` statements in the following files with appropriate logger calls (`logger.info`, `logger.warning`, `logger.error`):
        * `[x]` `backend/app/services/tracker.py`
        * `[x]` `backend/app/services/scraper.py`
        * `[x]` `backend/app/services/flipkart_scraper.py`
    * **Action:** In `tracker.py`, change the `except Exception as e` block to use `logger.exception("...")` to automatically capture the full stack trace in the log file.
    * **Reasoning:** Fulfills AC-1 by replacing `print()` with a formal, persistent logging mechanism.

* **Task 1.3: Implement File-based Locking**
    * `[x]` **Status: DONE**
    * **Action:** In `backend/app/config.py`, add a new variable `LOCK_FILE = os.path.join(os.path.dirname(os.path.dirname(__file__)), 'tracker.lock')`.
    * **Action:** Modify the `run_price_tracker` function in `tracker.py`.
        * At the very beginning, check if the lock file exists. If it does, log a warning (`"Previous run is still active. Exiting."`) and `return`.
        * Wrap the entire tracking logic in a `try...finally` block.
        * In the `try` block, create the empty lock file immediately.
        * In the `finally` block, ensure the lock file is removed.
    * **Reasoning:** Fulfills AC-1 and AC-3 by preventing concurrent runs and ensuring graceful handling if a previous job is still active. The `finally` block guarantees cleanup.

---

#### Phase 2: Scheduling & Deployment (AC-2)

*This phase focuses on setting up the automated execution environment.*

* **Task 2.1: Document Environment Paths**
    * `[x]` **Status: DONE**
    * **Goal:** Find the absolute paths needed for the cron job.
    * **Step 1 (VENV Python):** Activate the virtual environment (`source venv/bin/activate`) and run `which python`. Record the full path (e.g., `/home/user/priceTrackerApp/backend/venv/bin/python`).
    * **Step 2 (Project Script):** Get the absolute path to the tracker script (e.g., `/home/user/priceTrackerApp/backend/app/services/tracker.py`).
    * **Step 3 (System PATH):** In the same active terminal, run `echo $PATH`. Record this entire string. This is critical for Playwright to find its browser dependencies.

* **Task 2.2: Create Cron Job**
    * `[ ]` **Status: NOT_STARTED**
    * **Action:** Open the crontab editor by running `crontab -e`.
    * **Action:** Add the following lines to the file, replacing the placeholder paths with the ones recorded in Task 2.1.

    ```bash
    # Set the PATH to ensure all dependencies, especially for Playwright, are found
    PATH=/recorded/path/from/echo/command

    # Run the Price Tracker App script every 10 minutes
    */10 * * * * /path/to/venv/python /path/to/project/backend/app/services/tracker.py
    ```
    * **Reasoning:** Fulfills AC-2 by scheduling the script to run every 10 minutes using the correct virtual environment and a properly configured `PATH` for reliability. The script's internal logging handles all output, so no shell redirection is needed.

---

Dark mode - > 

## ✅ Dark Mode Feature Checklist (EPT-132)

### Task 1: Create Theme Context
- [x] Create new file `src/context/ThemeContext.js`.
- [x] Implement state management for the theme (`'light'` or `'dark'`).
- [x] Implement `toggleTheme` function.
- [x] Add `useEffect` to read initial theme from `localStorage` or `prefers-color-scheme`.
- [x] Add `useEffect` to toggle the `dark` class on the `<html>` element.
- [x] Add `useEffect` to write the current theme to `localStorage` on change.
- [x] Export `ThemeProvider` component and `useTheme()` custom hook.

### Task 2: Configure Tailwind CSS
- [x] Locate and open `tailwind.config.js`.
- [x] Add `darkMode: 'class'` to the configuration.

### Task 3: Integrate ThemeProvider
- [x] Import `ThemeProvider` in `src/App.js`.
- [x] Wrap the `<AuthProvider>` with the `<ThemeProvider>`.

### Task 4: Build Theme Toggle UI
- [x] Add new `sun` and `moon` SVG icon paths to the `icons` object in `Dashboard.jsx`.
- [x] Add a new `<button>` to the `<header>` section of `Dashboard.jsx`.
- [x] Use the `useTheme()` hook to get the current theme and `toggleTheme` function.
- [x] Implement conditional rendering for the Sun/Moon icons based on the current theme.
- [x] Attach the `toggleTheme` function to the button's `onClick` event.

### Task 5: Apply Dark Styles
- [x] **Dashboard.jsx**:
    - [x] Apply `dark:` variants to main page background (`bg-gray-100`).
    - [x] Apply `dark:` variants to the sidebar (`bg-white`).
    - [x] Apply `dark:` variants to all product cards, dropdowns, and menus (`bg-white`, text, borders).
    - [x] Apply `dark:` variants to all modals (`bg-white`, text, inputs, buttons).
    - [x] Apply `dark:` variants to text, inputs, and buttons in the header.
- [x] **Login.jsx & Signup.jsx**:
    - [x] Apply `dark:` variants to the main background and form container.
    - [x] Apply `dark:` variants to input fields, labels, and buttons.
    - [x] Ensure all text colors have sufficient contrast in dark mode.
- [ ] **index.css**:
    - [ ] Create a `.dark` parent selector block.
    - [ ] Add dark-themed `::-webkit-scrollbar-*` rules within the `.dark` block.
    - [ ] Update the Firefox `scrollbar-color` property for the `.dark` theme.