# E-commerce Price Tracker Project Log

## Objective

Develop a full-stack web application that monitors prices of products across various e-commerce websites and notifies users when prices drop below a certain threshold.

## Tech Stack

* **Backend**: FastAPI
* **Frontend**: React + Tailwind CSS
* **Scraping**: BeautifulSoup / Playwright / Selenium
* **Database**: MongoDB or PostgreSQL (TBD)
* **DevOps**: Docker, CI/CD, optional Kubernetes deployment
* **Notifications**: Email via SMTP / Push (TBD)

---

## Phase 1: Planning

**Start Date:** 2025-05-30

### Key Features

1. User Registration & Login
2. Product Tracker (Add product URLs, set desired price)
3. Scheduled Scraping (Monitor product prices regularly)
4. Price Drop Alerts (via email/notifications)
5. Dashboard to view tracked products and current prices
6. Graphs for price history trends (per product)

### Target Sites for Scraping (tentative)

* Amazon (caution: bot protection)
* Flipkart
* Croma
* Reliance Digital
* Public APIs (if any)

---

## Phase 2: Setup

**Status:** Done ✅

### Tasks

* [x] Set up project repo & file structure
* [x] Initialize FastAPI backend with basic routes
* [x] Set up React frontend with Tailwind CSS
* [x] Containerize backend and frontend with Docker
* [x] Configure MongoDB/PostgreSQL connection

---

## Phase 3: Core Backend Logic

**Status:** ongoing

### Tasks

* [x] Build user model and auth system
* [x] Implement product tracking model
* [x] Develop scraping module for target websites
* [x] Schedule scraping jobs using Celery/APScheduler (TBF)
* [ ] Integrate email/notification system (TBF)

---

## Phase 4: Frontend Development

**Status:** Pending

### Tasks

* [ ] Auth UI (login/signup) (yet to link them together)
* [ ] Dashboard to view tracked products
* [ ] Forms for adding/editing tracked products

---

## Phase 5: Deployment

**Status:** Pending

### Tasks

* [ ] CI/CD Pipeline (GitHub Actions)
* [ ] Docker Compose for local dev
* [ ] Production deployment (Render/AWS/DigitalOcean)

---

## Notes

* Explore usage of rotating user agents/proxies if bot detection becomes a problem
* Document all endpoints and create OpenAPI docs via FastAPI
* Include retry/failure handling in scraping logic
* Ensure legal/ethical scraping by reviewing site ToS

planned Project folder structure :- 
ecommerce-price-tracker/
├── backend/
│   ├── app/
│   │   ├── main.py
│   │   ├── models/
│   │   │   └── user.py, product.py
│   │   ├── routes/
│   │   │   └── auth.py, product.py
│   │   ├── services/
│   │   │   └── scraper.py, notification.py
│   │   └── config.py
│   ├── requirements.txt
│   └── Dockerfile
├── frontend/
│   ├── public/
│   ├── src/
│   │   ├── components/
│   │   ├── pages/
│   │   └── App.jsx
│   ├── tailwind.config.js
│   ├── package.json
│   └── Dockerfile
├── docker-compose.yml
├── .env (for secrets)
└── README.md

current backend folder - > 

C:\USERS\DINESH\DOCUMENTS\MP\PRICETRACKERAPP\BACKEND
│   .env
│   requirements.txt
│   
└───app
    │   config.py
    │   Dockerfile
    │   main.py
    │   __init__.py
    │
    ├───models
    │   │   product.py
    │   │   user.py
    │   │
    │   └───__pycache__
    │           product.cpython-311.pyc
    │           user.cpython-311.pyc
    │
    ├───routes
    │   │   auth.py
    │   │   product.py
    │   │
    │   └───__pycache__
    │           auth.cpython-311.pyc
    │           product.cpython-311.pyc
    │
    ├───services
    │   │   auth_utils.py
    │   │   flipkart_scraper.py
    │   │   scraper.py
    │   │   scraper_dispatcher.py
    │   │   tracker.py
    │   │
    │   └───__pycache__
    │           auth_utils.cpython-311.pyc
    │           flipkart_scraper.cpython-311.pyc
    │           scraper.cpython-311.pyc
    │           scraper_dispatcher.cpython-311.pyc
    │           tracker.cpython-311.pyc
    │
    ├───utils
    │   │   mongo.py
    │   │   objectid.py
    │   │
    │   └───__pycache__
    │           mongo.cpython-311.pyc
    │           objectid.cpython-311.pyc
    │
    └───__pycache__
            config.cpython-311.pyc
            main.cpython-311.pyc
            __init__.cpython-311.pyc

this is my current frontend structure - > frontend has three main folders - > node modules, sources and public here is public

```tree /f C:\Users\Dinesh\Documents\mp\priceTrackerApp\frontend\public
Folder PATH listing for volume OS
Volume serial number is 262A-D645
C:\USERS\DINESH\DOCUMENTS\MP\PRICETRACKERAPP\FRONTEND\PUBLIC
    favicon.ico
    index.html
    logo192.png
    logo512.png
    manifest.json
    robots.txt

No subfolders exist

(venv) PS C:\Users\Dinesh\Documents\mp\priceTrackerApp>```

and here is src - >

``` tree /f C:\Users\Dinesh\Documents\mp\priceTrackerApp\frontend\src   
Folder PATH listing for volume OS
Volume serial number is 262A-D645
C:\USERS\DINESH\DOCUMENTS\MP\PRICETRACKERAPP\FRONTEND\SRC
    App.css
    App.js
    App.test.js
    index.css
    index.js
    logo.svg
    reportWebVitals.js
    setupTests.js

No subfolders exist

(venv) PS C:\Users\Dinesh\Documents\mp\priceTrackerApp>```


next plan for product page - > 

Implementation Plan for Product Detail Page - Backend (Phase 1)
Last Updated: 2025-08-05

==================================================
AC-1: [DB Schema] Update Product Model
==================================================
File: app/models/product.py
Status: Pending

[x] 1.1: Create `PriceHistoryItem` Model
    - Define a new `BaseModel` called `PriceHistoryItem`.
    - It will contain `price: Optional[float]` (to handle failed scrapes) and `timestamp: datetime`.

[x] 1.2: Update `ProductInDB` Model
    - Add the new fields to the `ProductInDB` class:
        - `price_history: List[PriceHistoryItem] = []`
        - `historical_low_price: Optional[float] = None`
        - `historical_high_price: Optional[float] = None`

[x] 1.3: Update `ProductOut` Model
    - Mirror the changes from `ProductInDB` in the `ProductOut` class so the new data is sent to the frontend.

==================================================
AC-2: [Tracker Logic] Modify Tracker Script
==================================================
File: app/services/tracker.py (function: update_price_for_product)
Status: Pending

[x] 2.1: Adjust Price Parsing
    - Modify logic to set `price_num` to `None` if scraping fails or returns no price, instead of the current `0.0`.

[x] 2.2: Build Dynamic Update Payload
    - Construct a complex payload that ALWAYS uses `$push` to add a new `PriceHistoryItem` to the `price_history` array (with either the scraped price or `None`).

[x] 2.3: Implement Conditional `$set`
    - Add logic to build the `$set` object ONLY if `price_num` is not `None`:
      a) Set the `current_price`.
      b) Compare `price_num` with `product.get("historical_low_price")`. If it's a new low (or the first price), add `historical_low_price` to the `$set` object.
      c) Do the same for `historical_high_price`.

[x] 2.4: Execute Combined Update
    - Use the new payload in the `product_collection.update_one()` call, combining `$push` and `$set` operations into a single database write.

==================================================
AC-3: [New API Endpoint] Create GET /api/products/{id}
==================================================
File: app/routes/product.py
Status: Pending

[x] 3.1: Define New Route
    - Create a new endpoint: `@product_router.get("/{id}", response_model=ProductOut)`.

[x] 3.2: Add Authorization
    - Ensure the route uses the `current_user: UserInDB = Depends(get_current_user)` dependency.

[x] 3.3: Fetch Product with Ownership Check
    - Find the product where `_id` matches the path `id` AND `owner_id` matches `current_user.id`.

[x] 3.4: Handle Not Found
    - If no product is found, raise a `404 Not Found` HTTPException.

[x] 3.5: Return Product
    - If found, use the existing `format_product()` helper function to prepare and return the data.

==================================================
AC-4: [API Enhancement] Enhance PATCH /api/products/{id}
==================================================
File: app/routes/product.py and app/models/product.py
Status: Pending

[x] 4.1: Create `ProductUpdate` Model
    - In `app/models/product.py`, create a new model: `class ProductUpdate(BaseModel): desired_price: Optional[float] = None; notes: Optional[str] = None`.

[x] 4.2: Update Endpoint Signature
    - In `app/routes/product.py`, change the signature of the `update_product` function from `update_data: dict` to `update_data: ProductUpdate`.

[x] 4.3: Refine Update Logic
    - Replace the generic `update_data` dictionary with `update_data.model_dump(exclude_unset=True)` to build the `$set` payload cleanly and safely.


==================================================
Frontend Plan: Product Detail Page (Phase 2)
==================================================

This plan outlines the steps to create the new Product Detail page, leveraging the existing architecture and patterns.

--------------------------------------------------
Part 1: API and Routing Setup (AC-5)
--------------------------------------------------
Objective: Prepare the API layer for new requests and set up the new page route.

[X] 1.1: Enhance API Layer
    - File: src/api/api.js
    - Action: Add two new exported functions:
        - `getProductById(productId)`: Performs a GET request to `/api/products/${productId}`.
        - `updateProductDetails(productId, data)`: Performs a PATCH request to `/api/products/${productId}` with the provided data payload.

[x] 1.2: Add New Page Route
    - File: src/App.js
    - Action:
        - Import the new `ProductDetailPage` component (which we will create).
        - Add a new `<Route>` inside `<Routes>`:
          <Route path="/product/:id" element={<ProtectedRoute><ProductDetailPage /></ProtectedRoute>} />

[x] 1.3: Make Dashboard Products Clickable
    - File: src/pages/Dashboard.jsx
    - Action:
        - Import { Link } from "react-router-dom".
        - In the `.map()` function that renders product cards, wrap the main `div` of the card with a `<Link>` component.
        - The link's destination should be `to={'/product/${product.id}'}`.

--------------------------------------------------
Part 2: Build ProductDetailPage Component (AC-6, AC-10)
--------------------------------------------------
Objective: Create the main page component, fetch data, and handle loading/error states.

[x] 2.1: Create New Component File
    - New File: src/pages/ProductDetailPage.jsx

[x] 2.2: Set Up Component State
    - Action: Inside the `ProductDetailPage` component:
        - Get the product ID from the URL using the `useParams` hook.
        - Initialize state variables using `useState`:
            - `product` (default: null)
            - `isLoading` (default: true)
            - `error` (default: null)

[x] 2.3: Fetch Product Data
    - Action: Use a `useEffect` hook to fetch data when the component loads.
        - Call the `getProductById(id)` function from `api.js`.
        - On success, update the `product` state.
        - On failure, update the `error` state.
        - Use a `finally` block to set `isLoading` to `false`.

[x] 2.4: Implement Conditional Rendering
    - Action: In the JSX, render content based on the state:
        - If `isLoading`, show a loading message/spinner.
        - If `error`, show an error message.
        - If `product` is loaded, render the page content.

--------------------------------------------------
Part 3: Implement UI Panels (AC-7, AC-8, AC-9)
--------------------------------------------------
Objective: Build the three main UI sections of the page within ProductDetailPage.jsx.

[x] 3.1: Build Vitals Panel (AC-7)
    - Action: Create a section to display the key price points.
        - Render `product.current_price`, `product.desired_price`, `product.historical_low_price`, and `product.historical_high_price`.
        - Add a small up/down arrow icon next to the current price by comparing the last two entries in `product.price_history`.

[x] 3.2: Build Price History Chart (AC-8)
    - Action:
        - Install a charting library: `npm install recharts`.
        - Create state for the active time range filter: `const [timeRange, setTimeRange] = useState('All');`
        - Create buttons (1W, 1M, 6M, All) that update this `timeRange` state.
        - Write a helper function to filter `product.price_history` based on the selected `timeRange`.
        - Render the Recharts `<LineChart>` component with the filtered data.
        - Configure the `<Tooltip>` to show price and formatted date on hover. (Recommended: `npm install date-fns`).

[x] 3.3: Build User Settings Panel (AC-9)
    - Action:
        - Create a `<form>` element for user settings.
        - Use controlled components for the `desired_price` input and `notes` textarea. This will require new state variables.
        - Use a `useEffect` to populate these form fields with `product.desired_price` and `product.notes` once the product data is loaded.
        - The "Save" button's `onClick` handler will call the `updateProductDetails()` API function with the new form values.
        - Add state to handle the saving process (e.g., a "Saving..." message on the button).