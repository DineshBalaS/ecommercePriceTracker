# E-commerce Price Tracker Project Log

## Objective

Develop a full-stack web application that monitors prices of products across various e-commerce websites and notifies users when prices drop below a certain threshold.

## Tech Stack

* **Backend**: FastAPI
* **Frontend**: React + Tailwind CSS
* **Scraping**: BeautifulSoup / Playwright / Selenium
* **Database**: MongoDB or PostgreSQL (TBD)
* **DevOps**: Docker, CI/CD, optional Kubernetes deployment
* **Notifications**: Email via SMTP / Push (TBD)

---

## Phase 1: Planning

**Start Date:** 2025-05-30

### Key Features

1. User Registration & Login
2. Product Tracker (Add product URLs, set desired price)
3. Scheduled Scraping (Monitor product prices regularly)
4. Price Drop Alerts (via email/notifications)
5. Dashboard to view tracked products and current prices
6. Graphs for price history trends (per product)

### Target Sites for Scraping (tentative)

* Amazon (caution: bot protection)
* Flipkart
* Croma
* Reliance Digital
* Public APIs (if any)

---

## Phase 2: Setup

**Status:** Done ✅

### Tasks

* [x] Set up project repo & file structure
* [x] Initialize FastAPI backend with basic routes
* [x] Set up React frontend with Tailwind CSS
* [x] Containerize backend and frontend with Docker
* [x] Configure MongoDB/PostgreSQL connection

---

## Phase 3: Core Backend Logic

**Status:** ongoing

### Tasks

* [x] Build user model and auth system
* [x] Implement product tracking model
* [x] Develop scraping module for target websites
* [x] Schedule scraping jobs using Celery/APScheduler (TBF)
* [ ] Integrate email/notification system (TBF)

---

## Phase 4: Frontend Development

**Status:** Pending

### Tasks

* [ ] Auth UI (login/signup) (yet to link them together)
* [ ] Dashboard to view tracked products
* [ ] Forms for adding/editing tracked products

---

## Phase 5: Deployment

**Status:** Pending

### Tasks

* [ ] CI/CD Pipeline (GitHub Actions)
* [ ] Docker Compose for local dev
* [ ] Production deployment (Render/AWS/DigitalOcean)

---

## Notes

* Explore usage of rotating user agents/proxies if bot detection becomes a problem
* Document all endpoints and create OpenAPI docs via FastAPI
* Include retry/failure handling in scraping logic
* Ensure legal/ethical scraping by reviewing site ToS

planned Project folder structure :- 
ecommerce-price-tracker/
├── backend/
│   ├── app/
│   │   ├── main.py
│   │   ├── models/
│   │   │   └── user.py, product.py
│   │   ├── routes/
│   │   │   └── auth.py, product.py
│   │   ├── services/
│   │   │   └── scraper.py, notification.py
│   │   └── config.py
│   ├── requirements.txt
│   └── Dockerfile
├── frontend/
│   ├── public/
│   ├── src/
│   │   ├── components/
│   │   ├── pages/
│   │   └── App.jsx
│   ├── tailwind.config.js
│   ├── package.json
│   └── Dockerfile
├── docker-compose.yml
├── .env (for secrets)
└── README.md

current backend folder - > 

C:\USERS\DINESH\DOCUMENTS\MP\PRICETRACKERAPP\BACKEND
│   .env
│   requirements.txt
│   
└───app
    │   config.py
    │   Dockerfile
    │   main.py
    │   __init__.py
    │
    ├───models
    │   │   product.py
    │   │   user.py
    │   │
    │   └───__pycache__
    │           product.cpython-311.pyc
    │           user.cpython-311.pyc
    │
    ├───routes
    │   │   auth.py
    │   │   product.py
    │   │
    │   └───__pycache__
    │           auth.cpython-311.pyc
    │           product.cpython-311.pyc
    │
    ├───services
    │   │   auth_utils.py
    │   │   flipkart_scraper.py
    │   │   scraper.py
    │   │   scraper_dispatcher.py
    │   │   tracker.py
    │   │
    │   └───__pycache__
    │           auth_utils.cpython-311.pyc
    │           flipkart_scraper.cpython-311.pyc
    │           scraper.cpython-311.pyc
    │           scraper_dispatcher.cpython-311.pyc
    │           tracker.cpython-311.pyc
    │
    ├───utils
    │   │   mongo.py
    │   │   objectid.py
    │   │
    │   └───__pycache__
    │           mongo.cpython-311.pyc
    │           objectid.cpython-311.pyc
    │
    └───__pycache__
            config.cpython-311.pyc
            main.cpython-311.pyc
            __init__.cpython-311.pyc

this is my current frontend structure - > frontend has three main folders - > node modules, sources and public here is public

```tree /f C:\Users\Dinesh\Documents\mp\priceTrackerApp\frontend\public
Folder PATH listing for volume OS
Volume serial number is 262A-D645
C:\USERS\DINESH\DOCUMENTS\MP\PRICETRACKERAPP\FRONTEND\PUBLIC
    favicon.ico
    index.html
    logo192.png
    logo512.png
    manifest.json
    robots.txt

No subfolders exist

(venv) PS C:\Users\Dinesh\Documents\mp\priceTrackerApp>```

and here is src - >

``` tree /f C:\Users\Dinesh\Documents\mp\priceTrackerApp\frontend\src   
Folder PATH listing for volume OS
Volume serial number is 262A-D645
C:\USERS\DINESH\DOCUMENTS\MP\PRICETRACKERAPP\FRONTEND\SRC
    App.css
    App.js
    App.test.js
    index.css
    index.js
    logo.svg
    reportWebVitals.js
    setupTests.js

No subfolders exist

(venv) PS C:\Users\Dinesh\Documents\mp\priceTrackerApp>```


next plan for product page - > 

Implementation Plan for Product Detail Page - Backend (Phase 1)
Last Updated: 2025-08-05

==================================================
AC-1: [DB Schema] Update Product Model
==================================================
File: app/models/product.py
Status: Pending

[ ] 1.1: Create `PriceHistoryItem` Model
    - Define a new `BaseModel` called `PriceHistoryItem`.
    - It will contain `price: Optional[float]` (to handle failed scrapes) and `timestamp: datetime`.

[ ] 1.2: Update `ProductInDB` Model
    - Add the new fields to the `ProductInDB` class:
        - `price_history: List[PriceHistoryItem] = []`
        - `historical_low_price: Optional[float] = None`
        - `historical_high_price: Optional[float] = None`

[ ] 1.3: Update `ProductOut` Model
    - Mirror the changes from `ProductInDB` in the `ProductOut` class so the new data is sent to the frontend.

==================================================
AC-2: [Tracker Logic] Modify Tracker Script
==================================================
File: app/services/tracker.py (function: update_price_for_product)
Status: Pending

[ ] 2.1: Adjust Price Parsing
    - Modify logic to set `price_num` to `None` if scraping fails or returns no price, instead of the current `0.0`.

[ ] 2.2: Build Dynamic Update Payload
    - Construct a complex payload that ALWAYS uses `$push` to add a new `PriceHistoryItem` to the `price_history` array (with either the scraped price or `None`).

[ ] 2.3: Implement Conditional `$set`
    - Add logic to build the `$set` object ONLY if `price_num` is not `None`:
      a) Set the `current_price`.
      b) Compare `price_num` with `product.get("historical_low_price")`. If it's a new low (or the first price), add `historical_low_price` to the `$set` object.
      c) Do the same for `historical_high_price`.

[ ] 2.4: Execute Combined Update
    - Use the new payload in the `product_collection.update_one()` call, combining `$push` and `$set` operations into a single database write.

==================================================
AC-3: [New API Endpoint] Create GET /api/products/{id}
==================================================
File: app/routes/product.py
Status: Pending

[ ] 3.1: Define New Route
    - Create a new endpoint: `@product_router.get("/{id}", response_model=ProductOut)`.

[ ] 3.2: Add Authorization
    - Ensure the route uses the `current_user: UserInDB = Depends(get_current_user)` dependency.

[ ] 3.3: Fetch Product with Ownership Check
    - Find the product where `_id` matches the path `id` AND `owner_id` matches `current_user.id`.

[ ] 3.4: Handle Not Found
    - If no product is found, raise a `404 Not Found` HTTPException.

[ ] 3.5: Return Product
    - If found, use the existing `format_product()` helper function to prepare and return the data.

==================================================
AC-4: [API Enhancement] Enhance PATCH /api/products/{id}
==================================================
File: app/routes/product.py and app/models/product.py
Status: Pending

[ ] 4.1: Create `ProductUpdate` Model
    - In `app/models/product.py`, create a new model: `class ProductUpdate(BaseModel): desired_price: Optional[float] = None; notes: Optional[str] = None`.

[ ] 4.2: Update Endpoint Signature
    - In `app/routes/product.py`, change the signature of the `update_product` function from `update_data: dict` to `update_data: ProductUpdate`.

[ ] 4.3: Refine Update Logic
    - Replace the generic `update_data` dictionary with `update_data.model_dump(exclude_unset=True)` to build the `$set` payload cleanly and safely.